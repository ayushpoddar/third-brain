![rw-book-cover](https://readwise-assets.s3.amazonaws.com/static/images/article3.5c705a01b476.png)

## Metadata
- Author: [[jkatz05.com]]
- Full Title: Vectors Are the New JSON in PostgreSQL
- URL: https://jkatz05.com/post/postgres/vectors-json-postgresql/?utm_source=tldrnewsletter

## Highlights
- Vectors are not new, but they’re having a surge in popularity these days. As mentioned earlier, this is due to the newfound accessibility of AI/ML systems, and that the output of these systems are vectors. A common use-case is to build a model on stored data (text, sound, video), convert it to vector format, and then use it for “[semantic search](https://en.wikipedia.org/wiki/Semantic_search).” In this case, semantic search is performed when you take a new input, convert it to its corresponding vector, and find the most similar results in the database. Similarity is found using a [distance function](https://en.wikipedia.org/wiki/Distance), such as [Euclidean](https://en.wikipedia.org/wiki/Euclidean_distance) or [cosine distance](https://en.wikipedia.org/wiki/Cosine_similarity), and the results are often capped at the “[**k** nearest neighbors](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)” (K-NN), or **k** most similar objects. It can take a lot of time to encode the “training set” of vectors, so it makes sense to “cache” them in a permanent data storage system, such as a database, and perform K-NN queries there. Having a set of vectors that are ready to be queried for semantic searches makes a generally better experience for users, which has given rise to the notion of needing a “vector database.” ([View Highlight](https://read.readwise.io/read/01h7yjyac87vpvb34gky24wfbg))
- This gives us [pgvector](https://github.com/pgvector/pgvector), an open source [PostgreSQL extension](https://www.postgresql.org/docs/current/extend-extensions.html) that provides an indexable `vector` data type. In a nutshell, pgvector lets you store vectors in PostgreSQL and perform K-NN queries with an assortment of distance metrics: Euclidean, cosine, and inner product. As of today, pgvector comes with one index, `ivfflat`, which implements the [IVF FLAT](https://github.com/facebookresearch/faiss/wiki/Faiss-indexes) method of vector indexing. ([View Highlight](https://read.readwise.io/read/01h7ym42fr9ynejazy1t9jh4k3))
- What happens when you query indexed vector data may be a bit different than how you’re used to querying data in PostgreSQL. Due to the computational expense of performing nearest-neighbor searches over high-dimensionality vectors, many vector indexing methods look for “approximate” answers that are “close enough” to the correct answer. This has lead to the field of “Approximate Nearest Neighbor” (ANN) searches. The two dimensions that people look at for ANN queries are the tradeoff between performance and “[recall](https://en.wikipedia.org/wiki/Precision_and_recall)”, where “recall” is the percentage of relevant results returned. ([View Highlight](https://read.readwise.io/read/01h7ym43wgd0jk1myhg1fxfdvn))
- Let’s look at the `ivfflat` method as an example. When building an `ivfflat` index, you decide how many `lists` you want to have in it. Each `list` represents a “center”; these centers are calculated using a [k-means](https://en.wikipedia.org/wiki/K-means_clustering) algorithm. Once you determine all of your centers, `ivfflat` determines what center each vector is closest to and adds it to the index. When it’s time to query your vector data, you then decide how many centers to check, which is determined by the `ivfflat.probes` parameter. This is where you see the ANN performance/recall tradeoff: the more centers you visit, the more precise your results, but at the expense of performance. ([View Highlight](https://read.readwise.io/read/01h7ym4zk7vfxwn7gj1mvc0sbh))
