![rw-book-cover](https://mcfunley.com/assets/images/mountains-square.jpg)

## Metadata
- Author: [[Dan McKinley]]
- Full Title: Choose Boring Technology
- URL: https://mcfunley.com/choose-boring-technology

## Highlights
- Let’s say every company gets about three innovation tokens ([View Highlight](https://read.readwise.io/read/01gzjy9ategdkg9e1ce3cdhr2r))
- If you choose to write your website in NodeJS, you just spent one of your innovation tokens. If you choose to use [MongoDB](https://mcfunley.com/why-mongodb-never-worked-out-at-etsy), you just spent one of your innovation tokens. If you choose to use [service discovery tech that’s existed for a year or less](https://consul.io/), you just spent one of your innovation tokens. If you choose to write your own database, oh god, you’re in trouble. ([View Highlight](https://read.readwise.io/read/01gzjy9c72axngcq1127gngqt9))
- Any of those choices might be sensible if you’re a javascript consultancy, or a database company. But you’re probably not. You’re probably working for a company that is at least ostensibly [rethinking global commerce](https://www.etsy.com) or [reinventing payments on the web](https://stripe.com) or pursuing some other suitably epic mission. In that context, devoting any of your limited attention to innovating ssh is an excellent way to fail. Or at best, delay success [[1]](https://mcfunley.com/choose-boring-technology#f1). ([View Highlight](https://read.readwise.io/read/01gzjy9d4d0dw1yt71bxfnept2))
- What counts as boring? That’s a little tricky. “Boring” should not be conflated with “bad.” There is technology out there that is both boring and bad [[2]](https://mcfunley.com/choose-boring-technology#f2). You should not use any of that. But there are many choices of technology that are boring and good, or at least good enough. MySQL is boring. Postgres is boring. PHP is boring. Python is boring. Memcached is boring. Squid is boring. Cron is boring. ([View Highlight](https://read.readwise.io/read/01gzjya0r6qxyyfvsx03vew3tp))
- When choosing technology, you have both known unknowns and unknown unknowns [[3]](https://mcfunley.com/choose-boring-technology#f3). ([View Highlight](https://read.readwise.io/read/01gzrfq8eqnx6dgbtw1nwesqaf))
- A known unknown is something like: *we don’t know what happens when this database hits 100% CPU.* ([View Highlight](https://read.readwise.io/read/01gzrfqf9t5hs4deeq77ks7a5v))
- A known unknown is something like: *we don’t know what happens when this database hits 100% CPU.* ([View Highlight](https://read.readwise.io/read/01gzrfqkc7hky5fp9rwfg1sqyp))
- An unknown unknown is something like: *geez it didn’t even occur to us that [writing stats would cause GC pauses](http://www.evanjones.ca/jvm-mmap-pause.html).* ([View Highlight](https://read.readwise.io/read/01gzrfqnb53nreb01nzrkjxvte))
- Both sets are typically non-empty, even for tech that’s existed for decades. But for shiny new technology the magnitude of unknown unknowns is significantly larger, and this is important. ([View Highlight](https://read.readwise.io/read/01gzrfqxxcep0pwf5z8a3wqay2))
- [Your function in a nutshell](https://twitter.com/coda/status/580531932393504768) is to map business problems onto a solution space that involves choices of software. If the choices of software were truly without baggage, you could indeed pick a whole mess of locally-the-best tools for your assortment of problems. ([View Highlight](https://read.readwise.io/read/01gzrvc5e0mr1agm97c8gcr8xw))
- The problem with “best tool for the job” thinking is that it takes a myopic view of the words “best” and “job.” Your job is keeping the company in business, god damn it. And the “best” tool is the one that occupies the “least worst” position for as many of your problems as possible. ([View Highlight](https://read.readwise.io/read/01gzsa7z6kmw824gv9zctjqapj))
- It is basically always the case that the long-term costs of keeping a system working reliably vastly exceed any inconveniences you encounter while building it. Mature and productive developers understand this. ([View Highlight](https://read.readwise.io/read/01gzsa8btexqb1965wdd3p0ax9))
- An important first step is to acknowledge that this is a process, and a conversation. New tech eventually has company-wide effects, so adding tech is a decision that requires company-wide visibility. Your organizational specifics may force the conversation, or [they may facilitate developers adding new databases and queues without talking to anyone](https://twitter.com/mcfunley/status/578603932949164032). One way or another you have to set cultural expectations that **this is something we all talk about**. ([View Highlight](https://read.readwise.io/read/01gzsaac6sq9gmtqp0ay547fd7))
- One of the most worthwhile exercises I recommend here is to **consider how you would solve your immediate problem without adding anything new**. First, posing this question should detect the situation where the “problem” is that someone really wants to use the technology. If that is the case, you should immediately abort. ([View Highlight](https://read.readwise.io/read/01gzsaaypvh7x014vs00xpygdn))
- It’s helpful to **write down exactly what it is about the current stack that makes solving the problem prohibitively expensive and difficult.** This is related to the previous exercise, but it’s subtly different. ([View Highlight](https://read.readwise.io/read/01gzsac2bjc1agv92sppe9089w))
- New technology choices might be purely additive (for example: “we don’t have caching yet, so let’s add memcached”). But they might also overlap or replace things you are already using. If that’s the case, you should **set clear expectations about migrating old functionality to the new system.** The policy should typically be “we’re committed to migrating,” with a proposed timeline. The intention of this step is to keep wreckage at manageable levels, and to avoid proliferating locally-optimal solutions. ([View Highlight](https://read.readwise.io/read/01gzsadq7h5e237bred44hp1j8))
